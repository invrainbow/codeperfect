I type super fast and use keyboard shortcuts for everything.
Because of this, I noticed early on that my IDE was often failing to keep up with me.
It would take forever to start up, and freeze and lag when I typed.

Then it occurred to me: software today in general is just slow. Almost all the
software I use takes forever to start up, and freezes and lags randomly. I don't
[seem](https://www.google.com/search?q=site%3Areddit.com+vscode+slow)
[to](https://www.google.com/search?q=site%3Areddit.com+jetbrains+slow)
[be](https://www.google.com/search?q=site%3Areddit.com+visual+studio+slow)
alone. Nor is the phenomenon
[limited](https://www.google.com/search?q=site%3Areddit.com+slack+slow) 
[to](https://www.google.com/search?q=site%3Areddit.com+notion+slow) 
[IDEs](https://www.google.com/search?q=site%3Areddit.com+figma+slow).

Why? Why is modern software so slow? Is there a physical law about transistors
or something that prevents software from surpassing a certain speed?

Software used to be fast. Visual C++ 6.0 [opens
instantly](https://twitter.com/rogerclark/status/1247299730314416128). Why
doesn't Visual Studio? Why don't any of my programs?

I can't say how most programs work. Maybe some fundamental law of math forces
most programs to be slow. But I know how an IDE works. All an IDE really needs
to do is (a) let you edit a text buffer, (b) parse your source files, and (c)
build an understanding of your code so it can provide you with intellisense.
What's hard about that? Why is my IDE slow?

<br><br>

My Mac mini has a 3 GHz Intel Core i5. That 3 GHz means it performs 3 billion
operations per second. Each operation is something like copying a number,
grabbing an instruction, adding two numbers &mdash; some processor primitive.
Let's generously give two thirds to the operating system. So every second, we
get a budget of a billion operations, and we have to spend it correctly to get
a fast, working IDE.

How many cycles would our IDE need in order to do its job? Draw 60 images,
process any edits I made in the last second, and do a second's worth of work
analyzing some source code. How many operations is that?

Is the true number anywhere *close* to a billion?

I'd feel pretty confident saying that judging by the math, IDEs should be at
least ten times faster than they currently are, and never lag. If you break
down what an IDE needs to do into individual tasks, and add up the number of
cycles each task roughly takes, I'd feel pretty silly proposing that an IDE
needs more than 100 million cycles per second to do its job.

If you gave someone a billion dollars to build a bridge, and after spending it
all he failed to produce a bridge, you'd lose your patience. But when you give
a program a billion CPU cycles, and after spending them it fails to draw 60
pictures, that's regarded as the normal, inevitable state of software in 2021.

<br><br>

So why does this happen?

Hardware isn't the issue. Hardware is plenty fast. Our computers are
supercomputers by yesterday's standards. The issue is how we spend those CPU
cycles.

What gets measured gets improved. What doesn't, doesn't. I think that's the
problem. We don't really count CPU cycles anymore. It isn't any one thing that
makes software slow. We've just stopped caring about the speed of software altogether,
exceptly as barely an afterthought.

Imagine you work at a company and your team is considering building an IDE.
What would probably happen? Current fashions would suggest writing the app in
JavaScript using Electron. Writing it in JavaScript will mean lots of people to
hire, your coworker will argue. A strong ecosystem of libraries means faster
time to market. Electron means we don't have to worry about platform-specific
APIs, and we can use all the web technologies we're already familiar with. Yay!

What's happening under the hood? Before that IDE even does anything, it's
compiled into a website and loaded into Chrome, which loads *an entire virtual
machine* and does a bunch of crazy stuff. Then the IDE sits inside the
JavaScript runtime, where everything is a callback, no one cares about memory
usage, and garbage collection runs around all day running on full blast. I have
no trouble believing you could spend a billion cycles in a second like this.

Notice that the issue isn't even any particular slow thing Electron does. It's
that all of these slow things are done before any consideration fo speed is
even made.  By the time users start complaining the IDE is slow, all the
assumptions have already been locked in place.  Say the team brings in an
optimization specialist to fix things. What can he do? Profile, measure,
optimize. But the issue probably isn't even any individual function that's
slow. It's the whole environment and paradigm the IDE lives in.

All this just to draw 60 pictures, modify an in-memory buffer, and parse some
source code.

<br><br>

${IDE_NAME} is our attempt to start over. Our approach is simple: we count CPU
cycles. We don't write any code that doesn't directly do something we want to
do.

What are we *actually* trying to do? Not much: draw some pictures, edit a
buffer, parse some source code. So let's just do that.

 *  Draw pictures: use the GPU, something like OpenGL.
 *  Buffer: in-memory array.
 *  Parse source code: recursive descent parser.

The first version of ${IDE_NAME} was literally a C/OpenGL program, practically
a single giant `main()` function, that read a file into an array in memory, rendered
it, processed keystrokes, and parsed your Go source files in the background.
You would not believe *how blistering fast* it was. I think it
was rendering over 1,000 FPS.

${IDE_NAME} today is essentially the same program. At its core it's a
blistering fast renderer, text editor, and Go source analyzer. Everything else
is built on top of that.

<br><br>

The long-term plan is:

1. Build a tiny, super fast core consisting of a text editor and parser.

2. Build enough useful features on top of that core to be just barely usable as
an IDE, while still cutting out all superfluous CPU cycles. This is like our
MVP.

3. Build the rest of Jetbrains piecemeal, while cutting out all superfluous CPU cycles.

We're just about done with 2. Right now the IDE is basically a text editor that
understands Go. It has a complete mental model about your code and can answer
any question about it. Using that we've implemented things like autocomplete,
parameter hints, and jump to definition. The IDE is usable enough to function
as a daily driver.

Our priority right now is to stay on top of bugs, and start building out the
rest of the features an IDE needs. We want to improve autocomplete by
displaying more info about each item, for example, and add automatic
refactoring. At this point, most of the work is product work.  We have the core
technology to understand and manipulate Go source trees; our job now is to
implement high-level features and build a good UX.

The IDE is very much unfinished.  Right now it only works on Windows; your
project has to be a single module; it freezes when opening super huge
directories. But as long as we continue building the IDE with our bottom-up
approach, starting from a small, super fast core and steadily building atop it
without leaking CPU cycles, all of these problems are temporary. We have a lot
of work to do. But we're not *fundamentally* limited in our speed the way we
would be without our fast core.

<br><br>

In recent history the benefits of Moore's law have mostly gone to developers.
Computers have gotten way faster, but software has not gotten way better.
Where did those extra CPU cycles all go? Apparently, developers took them all.
All those cycles went towards letting developers write
JavaScript/React/Electron apps instead of drawing their own UI in C.

That has its legitimate uses. This website was built in React. But we think
that at least some of the time, the benefits of Moore's law ought to be passed
on to users. And there's no reason they can't be. IDEs don't do anything that
requires super insane, quantum computing, Large Hadron Collider levels of
power. We're not factoring humongous prime numbers or something. We
are just building a text editor plus parser.

That our IDEs are so slow is mostly an unfortunate collective decision by engineers to
prioritize their preferences over benefiting users. There's a supercomputer
right on your desk, and most of its cycles are going towards supporting
developers' massively expensive choices. We could instead repurpose those
cycles towards benefiting you, the user, and computing things that are actually
useful to you. That's our goal.

<br><br>

### Related Links

 * [The Thirty Million Line Problem](https://caseymuratori.com/blog_0031), Casey Muratori
 * [Preventing the Collapse of Civilization](https://www.youtube.com/watch?v=ZSRHeXYDLko), Jonathan Blow
 * [Data-Oriented Design and C++](https://www.youtube.com/watch?v=rX0ItVEVjHc), Mike Acton
