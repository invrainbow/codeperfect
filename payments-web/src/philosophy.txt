CodePerfect 95 is a new IDE for Go. Today we launched, and I want to take some
time to talk about the goals of the project.

<br>

### Slow

I'm a fast computer user. I use keyboard shortcuts for everything and type 160
wpm. At some point, I started noticing that most of the programs I use are too
slow to keep up with me. They take forever to start up, freeze for no reason,
and lag when I type stuff.

Then it occurred to me that software today in general is just slow. It manages
to stay usable because the hardware is so fast. But I think everyone knows what
I'm talking about. Almost all major applications take relatively forever to
start up, freeze randomly, and lag randomly.

Why? Why is software so slow? Is it an inherent limitation? Is there a physical
law about transistors or something that says software can't surpass a certain
speed?

Crazy thing is, software used to be fast. [Visual C++
6](https://twitter.com/rogerclark/status/1247299730314416128) opens instantly.
Why doesn't Visual Studio? Why don't any of my programs? Why does Slack take
five seconds to start?

I don't know how Slack works. Maybe some fundamental law of math prevents Slack
from starting up in under 5 seconds. I don't know. What I do know is how an IDE
works. So let's talk about an IDE.

What does an IDE do? It loads files into a buffer, which it renders and allows
you to edit. In the background, it reads your source files, and builds an
understanding of them into some kind of database. As you're typing, it queries
that database and give you answers in real time, like "what's the type of this
identifier?" and "what fields does this object have?"

The crazy thing is, that's basically it. There's more an IDE can do, of course.
But if I could trade the slow IDEs today that supposedly do a whole bunch of
things in exchange for an IDE that simply does the things above, super fast,
I'd take the super fast one. I don't think I'm alone.

<br>

### A Billion Operations

When you're investigating a phenomenon, one of the most useful things you can
do is analyze it from first principles. If you're building batteries, you might
break down the battery into its constituent parts and add up the cost of each
part. If your battery costs more than that, somewhere you're leaking money.

My Mac has a 3 GHz Intel Core i5.

3 GHz means it performs 3 billion operations per second. Each operation is
something like copying a number, grabbing an instruction, adding something
&mdash; some processor primitive. So we get a budget of 3 billion operations
per second, and we have to spend it correctly to get a fast, working IDE.

Let's generously donate 2/3 of that to the OS. We'll take a billion a second.
What would our IDE need to do its job? Render 60 images, send them to the
monitor, process any edits I made in the last second, and do a second's worth
of work analyzing some source code. How many operations is that?

I'll leave the Fermi estimates as an exercise for the reader. But whatever the
actual cost, is it even anywhere *in the ballpark* of a billion operations?

I guess what Jetbrains is telling me is that a billion operations isn't enough,
right? Presumably GoLand lags because I gave it too much to do and not
enough CPU cycles to do it; if I had a faster computer, and I didn't expect it
to perform such unreasonably Herculean tasks as rendering images, editing a
buffer, and parsing source code, then it would be able to do its job. Right?

This is the state of software today. If you gave me a billion dollars to build
a bridge, and after spending it all I failed to produce a bridge, you'd lose
your patience with me. But when you give a program a billion CPU cycles, and
after spending them it fails to draw 60 pictures, that's regarded as the
normal, inevitable state of software in 2021.

<br>

### Switching To a Happier Timeline

Let's start over. What would it take to build that IDE?

Hardware isn't the issue. The hardware is plenty fast. Our computers are
supercomputers by the standards of yesteryear. The issue is how we spend those
CPU cycles.

Say you work at a company and your team is considering building an IDE. What
will probably happen? Well, some well-meaning, well-paid engineer, dressed in a
neat button-down shirt and Patagonia jacket, will probably suggest writing the
app in JavaScript using Electron. He'll write a proposal listing all the pros
and cons. Writing it in JavaScript will mean lots of people to hire, he'll
argue. A strong ecosystem of libraries means faster time to market. Electron
means we don't have to worry about platform-specific APIs, and we can use all
the web technologies we're already familiar with. Yay!

This is how a billion cycles get squandered. Before that program even does
anything, first it's compiled into a website and loaded into Chrome, which loads
*a whole virtual machine* and does a bunch of stuff. Then the program sits
inside the land of JavaScript, where everything is a callback, no one cares
about memory usage, and garbage collection runs around all day running on full
blast.

All this just to draw 60 pictures, modify an in-memory buffer, and parse some
source code.

We think there's a better way. Per [Mike
Acton](https://www.youtube.com/watch?v=rX0ItVEVjHc), what is the *actual
problem we're trying to solve?* The problem is how to render pictures, edit a
buffer, and parse source code. So we're going to build that:

 *  How do you draw pictures? Using the GPU. The GPU is very good at drawing.
    Something like OpenGL would work.

 *  How do you maintain a buffer? An in-memory array. Arrays are great.

 *  How do you parse source code? A recursive descent parser will take source
    code and produce source trees.

That was the first version of ${IDE_NAME}. It was literally a C program,
crammed into `main()`, that read a file into memory, rendered it onto the
screen, accepted keystrokes, and parsed Go source files into trees. And you
would not believe *how blistering fast* it was. I think at that point it was
rendering over 1,000 FPS.

That's the heart of ${IDE_NAME}. We want to build an IDE that uses the fewest
CPU cycles possible. The core of our IDE is a blistering fast renderer, text
editor, and Go source analyzer. Everything else is built on top of that.

<br>

### The Plan

The plan is:

1. Build a tiny, super fast core that (a) lets you edit files and (b) parses
your source code.
2. Use/extend that core to provide specific useful features.
3. Add in the rest of Jetbrains piecemeal, while making sure the core stays
fast.

We're about halfway through 2 right now. At its core the IDE is a text editor
that deeply understands Go. It has a complete mental model about your code and
can answer any question. Using that database of knowledge, we've implemented
things like autocomplete, parameter hints, jump to definition.

Our priority right now is keeping our bugtracker empty, and steadily adding in
more features. We want to make autocomplete more helpful by displaying more
info about each item, and add automatic refactoring. At this point it's
product work: we have the core technology to understand and manipulate Go
source trees. Our job now is to build out a good user experience.

We built the IDE to only support a subset of use cases initially. Right now,
only Windows is supported, and your project has to be a single module. As we
grow, we'll be expanding to cover other cases (Mac support is high on our
list), without sacrificing that lightning fast core.

We've also tried to avoid premature optimization of edge cases. So ${IDE_NAME}
works very well in 95% of cases, but will flounder in the 5% of cases we didn't
handle. For instance, it currently freezes up for a few seconds when opening
super large directories. But this isn't an inherent limitation; we just haven't
handled that case yet. There are lots of edge cases like that. We're working
through them.

<br>

### Moore's Law

Strangely enough, the benefits of Moore's law have, historically speaking,
mostly gone to developers. Computers are way faster now, but software is not
way better. Where did those CPU cycles all go? Mostly towards "improving" the
developer experience. Developers now write JavaScript and Python instead of C,
and use React and Electron instead of drawing their own UI. That has its
legitimate uses. This website was built in React. But we think it would be nice
if, at least some of the time, the benefits of Moore's law were forwarded on to
the users.

The incredible thing is that there's no reason they can't be. There's nothing
an IDE does that requires a quantum computer. We're not factoring giant primes
or something. The fact that our programs are so slow is merely an unfortunate
collective decision on the part of engineers to prioritize their preferences
over benefiting users. There's a supercomputer on your desk, and most of its
cycles are going towards supporting the massively expensive choices made by
developers.

We could instead repurpose those cycles towards benefiting you, the user, and
computing things that are actually useful to you. That's our goal.

<br>

### Related Links

 * [The Thirty Million Line Problem](https://caseymuratori.com/blog_0031)
 * [Preventing the Collapse of Civilization](https://www.youtube.com/watch?v=ZSRHeXYDLko)
